{
  "Leetcode boilerplate": {
    "prefix": "leet",
    "body": [
      "#include<bits/stdc++.h>",
      "#ifndef ONLINE_JUDGE",
      "#include \"debug.h\"",
      "#else",
      "#define dbg(x...)",
      "#endif",
      "",
      "using namespace std;",
      "/* (╯°□°)╯︵ ┻━┻ */",
      "",
      "$1",
      "",
      "int main() {",
      "    $0",
      "    return 0;",
      "}"
    ],
    "description": "boilerplate code for leetcode problems in C++"
  },
  "Boilerplate with debug": {
    "prefix": "doi",
    "body": [
      "#include<bits/stdc++.h>",
      "#ifndef ONLINE_JUDGE",
      "#include \"debug.h\"",
      "#else",
      "#define dbg(x...)",
      "#endif",
      "",
      "using namespace std;",
      "/* (╯°□°)╯︵ ┻━┻ */",
      "",
      "#define int long long",
      "#define pii pair<int, int>",
      "#define endl \"\\n\"",
      "",
      "const int inf = 1e18;",
      "const int ninf = -1 * inf;",
      "int mod = 1e9 + 7;",
      "",
      "void solve() {",
      "    $0",
      "}",
      "",
      "int32_t main() {",
      "    ios_base::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    cout.tie(NULL);",
      "",
      "    int test_cases = 1;",
      "    $1cin >> test_cases;",
      "",
      "    while(test_cases--) {",
      "        solve();",
      "    }",
      "",
      "    return 0;",
      "}"
    ],
    "description": "boilerplate code for competitive programming in C++"
  },
  "Segment tree snippet": {
    "prefix": "segtree",
    "body": [
      "struct SegTree {",
      "    vector<int> tree;",
      "    int n;",
      "",
      "    SegTree(int sz) {",
      "        n = sz;",
      "        tree.resize(4 * n, 0);",
      "    }",
      "",
      "    void build(vector<int> &arr, int node, int start, int end) {",
      "        if (start == end) {",
      "            tree[node] = arr[start];",
      "        } else {",
      "            int mid = (start + end) / 2;",
      "            build(arr, 2 * node, start, mid);",
      "            build(arr, 2 * node + 1, mid + 1, end);",
      "",
      "            tree[node] = tree[2 * node] + tree[2 * node + 1];",
      "        }",
      "    }",
      "",
      "    void update(int node, int start, int end, int idx, int val) {",
      "        if (start == end) {",
      "            tree[node] = val;",
      "        } else {",
      "            int mid = (start + end) / 2;",
      "            if (idx <= mid) {",
      "                update(2 * node, start, mid, idx, val);",
      "            } else {",
      "                update(2 * node + 1, mid + 1, end, idx, val);",
      "            }",
      "",
      "            tree[node] = tree[2 * node] + tree[2 * node + 1];",
      "        }",
      "    }",
      "",
      "    int query(int node, int start, int end, int left, int right) {",
      "        if (right < start || end < left) return 0;",
      "        if (left <= start && end <= right) return tree[node];",
      "        int mid = (start + end) / 2;",
      "        int p1 = query(2 * node, start, mid, left, right);",
      "        int p2 = query(2 * node + 1, mid + 1, end, left, right);",
      "",
      "        return p1 + p2;",
      "    }",
      "};"
    ],
    "description": "Segment Tree implementation for range query problems"
  },
  "Sieve of Eratosthenes snippet for prime numbers": {
    "prefix": "sieve",
    "body": [
      "const int N = 2e6;",
      "vector<bool> isPrime(N, true);",
      "vector<int> primes;",
      "",
      "void sieve() {",
      "    isPrime[0] = isPrime[1] = false;",
      "    for (int i = 2; i * i < N; i++) {",
      "        if (isPrime[i]) {",
      "            for (int j = i * i; j < N; j += i) {",
      "                isPrime[j] = false;",
      "            }",
      "        }",
      "    }",
      "    for (int i = 2; i < N; i++) {",
      "        if (isPrime[i])",
      "            primes.push_back(i);",
      "    }",
      "}",
      "$0"
    ],
    "description": "Sieve of Eratosthenes for prime numbers"
  },
  "vectors": {
    "prefix": "vi",
    "body": ["vector<int> $1;", "$0"],
    "description": "Input vector of integers"
  },
  "vector<vector>": {
    "prefix": "vvi",
    "body": ["vector<vector<int>> $1($2, vector<int>($3));", "$0"],
    "description": "Input vector of integers"
  },
  "DSU (Disjoint Set Union)": {
    "prefix": "dsu",
    "body": [
      "class DSU {",
      "public:",
      "    vector<int> Parent, Rank;",
      "    ",
      "    DSU(int n) {",
      "        Parent.resize(n);",
      "        Rank.resize(n, 0);",
      "        for (int i = 0; i < n; i++) Parent[i] = i;",
      "    }",
      "    ",
      "    int Find(int x) {",
      "        if (Parent[x] != x) Parent[x] = Find(Parent[x]);",
      "        return Parent[x];",
      "    }",
      "    ",
      "    bool Union(int x, int y) {",
      "        int xset = Find(x), yset = Find(y);",
      "        if (xset != yset) {",
      "            Rank[xset] < Rank[yset] ? Parent[xset] = yset : Parent[yset] = xset;",
      "            Rank[xset] += Rank[xset] == Rank[yset];",
      "            return true;",
      "        }",
      "        return false;",
      "    }",
      "};",
      "$0"
    ],
    "description": "Disjoint Set Union (DSU) implementation"
  },
  "sortSnippet": {
    "prefix": "sa",
    "body": ["sort($1.begin(), $1.end() $2);", "$0"],
    "description": "Sort a vector"
  },
  "Trie": {
    "prefix": "trie",
    "body": [
      "struct TrieNode {",
      "    TrieNode *child[26];",
      "    bool isEnd;",
      "    TrieNode() {",
      "        isEnd = false;",
      "        for (int i = 0; i < 26; i++) child[i] = NULL;",
      "    }",
      "};",
      "",
      "void insert(TrieNode *root, string key) {",
      "    TrieNode *node = root;",
      "    for (char c : key) {",
      "        int idx = c - 'a';",
      "        if (!node->child[idx]) node->child[idx] = new TrieNode();",
      "        node = node->child[idx];",
      "    }",
      "    node->isEnd = true;",
      "}",
      "",
      "bool search(TrieNode *root, string key) {",
      "    TrieNode *node = root;",
      "    for (char c : key) {",
      "        int idx = c - 'a';",
      "        if (!node->child[idx]) return false;",
      "        node = node->child[idx];",
      "    }",
      "    return node->isEnd;",
      "}",
      "",
      "bool startsWith(TrieNode *root, string pref) {",
      "    TrieNode *node = root;",
      "    for (char c : pref) {",
      "        int idx = c - 'a';",
      "        if (!node->child[idx]) return false;",
      "        node = node->child[idx];",
      "    }",
      "    return true;",
      "}"
    ],
    "description": "Trie data structure with insert, search, and startsWith functions"
  },
  "Singly Linked List Node": {
    "prefix": "listnode",
    "body": [
      "struct ListNode {",
      "    int val;",
      "    ListNode *next;",
      "    ListNode(int x) {",
      "        val = x;",
      "        next = NULL;",
      "    }",
      "};"
    ],
    "description": "Snippet for a singly linked list node structure"
  },
  "Binary Tree Node": {
    "prefix": "btnode",
    "body": [
      "struct TreeNode {",
      "    int val;",
      "    TreeNode *left;",
      "    TreeNode *right;",
      "    TreeNode(int x) {",
      "        val = x;",
      "        left = NULL;",
      "        right = NULL;",
      "    }",
      "};"
    ],
    "description": "Snippet for a binary tree node structure"
  },
  "ordered_set": {
    "prefix": "pbds",
    "body": [
      "#include <ext/pb_ds/assoc_container.hpp> // Common file",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;"
    ],
    "description": "Include and define an ordered set"
  },
  "Custom Hash Struct": {
    "prefix": "custom_hash",
    "body": [
      "struct custom_hash {",
      "    static uint64_t splitmix64(uint64_t x) {",
      "        // http://xorshift.di.unimi.it/splitmix64.c",
      "        x += 0x9e3779b97f4a7c15;",
      "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
      "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
      "        return x ^ (x >> 31);",
      "    }",
      "",
      "    size_t operator()(uint64_t x) const {",
      "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
      "        return splitmix64(x + FIXED_RANDOM);",
      "    }",
      "};"
    ],
    "description": "Generates a custom hash function using splitmix64"
  },
  "Dijkstra Lambda Alt": {
    "prefix": "dijkstraAlt",
    "body": [
      "auto dj = [&](int src, vector<int> &spath) -> void {",
      "    priority_queue<pii, vector<pii>, greater<pii>> pq;",
      "    pq.push({0, src});",
      "    spath[src] = 0;",
      "",
      "    while (!pq.empty()) {",
      "        auto [curr_dis, curr_node] = pq.top();",
      "        pq.pop();",
      "",
      "        if (spath[curr_node] < curr_dis) continue;",
      "        for (auto [nei, dis] : adj[curr_node]) {",
      "            if (spath[nei] >= curr_dis + dis) {",
      "                spath[nei] = curr_dis + dis;",
      "                pq.push({spath[nei], nei});",
      "            }",
      "        }",
      "    }",
      "};"
    ],
    "description": "Dijkstra's algorithm (lambda) using custom spacing."
  },
  "Rabin-Karp Rolling Hash": {
    "prefix": "rabinkarp",
    "body": [
      "class RabinKarp {",
      "private:",
      "    const int BASE = 256;",
      "    const int MOD = 1000000007;",
      "    vector<long long> power;",
      "",
      "public:",
      "    RabinKarp(int maxLength) {",
      "        power.resize(maxLength);",
      "        power[0] = 1;",
      "        for (int i = 1; i < maxLength; i++) {",
      "            power[i] = (power[i-1] * BASE) % MOD;",
      "        }",
      "    }",
      "",
      "    long long computeHash(const string& s) {",
      "        long long hash = 0;",
      "        for (int i = 0; i < s.length(); i++) {",
      "            hash = (hash * BASE + s[i]) % MOD;",
      "        }",
      "        return hash;",
      "    }",
      "",
      "    long long updateHash(long long oldHash, char oldChar, char newChar, int patternLength) {",
      "        oldHash = (oldHash - oldChar * power[patternLength - 1]) % MOD;",
      "        if (oldHash < 0) oldHash += MOD;",
      "        return (oldHash * BASE + newChar) % MOD;",
      "    }",
      "};",
      "",
      "// Usage example:",
      "RabinKarp rk(${1:maxLength});",
      "string text = \"${2:text}\";",
      "string pattern = \"${3:pattern}\";",
      "",
      "long long patternHash = rk.computeHash(pattern);",
      "long long textHash = rk.computeHash(text.substr(0, pattern.length()));",
      "",
      "for (int i = 0; i <= text.length() - pattern.length(); i++) {",
      "    if (patternHash == textHash && text.substr(i, pattern.length()) == pattern) {",
      "        cout << \"Pattern found at index \" << i << endl;",
      "    }",
      "    if (i < text.length() - pattern.length()) {",
      "        textHash = rk.updateHash(textHash, text[i], text[i + pattern.length()], pattern.length());",
      "    }",
      "}",
      "$0"
    ],
    "description": "Rabin-Karp rolling hash algorithm implementation"
  },
  "rolling_hash": {
    "prefix": "rollhash",
    "body": [
      "const int N = 1e6 + 6;",
      "const __int128 base = 33;",
      "const __int128 mod = 1000000000000000003;",
      "__int128 add(__int128 a, __int128 b, __int128 mod) {",
      "    __int128 res = (a + b) % mod;",
      "    if (res < 0) res += mod;",
      "    return res;",
      "}",
      "__int128 mult(__int128 a, __int128 b, __int128 mod) {",
      "    __int128 res = (a * b) % mod;",
      "    if (res < 0) res += mod;",
      "    return res;",
      "}",
      "__int128 power(__int128 a, __int128 b, __int128 mod) {",
      "    __int128 res = 1;",
      "    while (b) {",
      "        if (b % 2 == 1) res = mult(res, a, mod);",
      "        a = mult(a, a, mod);",
      "        b /= 2;",
      "    }",
      "    return res;",
      "}",
      "__int128 pw[N];",
      "__int128 inv[N];",
      "__int128 ha[N];",
      "void precalc( ) {",
      "    pw[0] = 1;",
      "    for (int i = 1; i < N; i++) pw[i] = mult(pw[i - 1], base, mod);",
      "    __int128 pw_inv = power(base, mod - 2, mod);",
      "    inv[0] = 1;",
      "    for (int i = 1; i < N; i++) inv[i] = mult(inv[i - 1], pw_inv, mod);",
      "}",
      "void build(const std::string &s) {",
      "    int n = s.length( );",
      "    for (int i = 0; i < n; i++) {",
      "        ha[i] = add((i == 0) ? 0 : ha[i - 1], mult(pw[i], s[i] - 'a' + 1, mod), mod);",
      "    }",
      "}",
      "__int128 getHash(int x, int y) {",
      "    __int128 res = add(ha[y], (x == 0) ? 0 : -ha[x - 1], mod);",
      "    res = mult(res, inv[x], mod);",
      "    return res;",
      "}"
    ],
    "description": ""
  },
  "power_function": {
    "prefix": "poww",
    "body": [
      "int power(int a, int x) {",
      "    int res = 1;",
      "    while (x) {",
      "        if (x & 1) {",
      "            res = (res * a) % mod;",
      "        }",
      "        a = (a * a) % mod;",
      "        x >>= 1;",
      "    }",
      "    return res;",
      "}"
    ],
    "description": "modular exponentiation"
  },
  "bellman_ford": {
    "prefix": "bellman_ford",
    "body": [
      "    auto bellman_ford = [&]( ) -> void {",
      "        // propogation:",
      "        for (int i = 1; i < n; i++) {",
      "            for (auto e : edges) {",
      "                int a = e.a, b = e.b, x = e.x;",
      "                if (dist[a] != inf) {",
      "                    dist[b] = min(dist[a] + x, dist[b]);",
      "                    dist[b] = max(ninf, dist[b]);",
      "                }",
      "            }",
      "        }",
      " ",
      "        // negative cycle check:",
      "        for (int i = 1; i < n; i++) {",
      "            for (auto e : edges) {",
      "                int a = e.a, b = e.b, x = e.x;",
      "                if (dist[a] != inf) {",
      "                    dist[b] = max(ninf, dist[b]);",
      "                    if (dist[a] + x < dist[b]) {",
      "                        dist[b] = ninf;",
      "                    }",
      "                }",
      "            }",
      "        }",
      "    };",
      " "
    ],
    "description": ""
  },
  "topo_cycle": {
    "prefix": "topoc",
    "body": [
      "    vector<int> s_arr;",
      "    auto topo_cycle = [&]( ) -> bool {",
      "        queue<int> q;",
      "",
      "        for (int i = 1; i <= n; i++) {",
      "            if (indeg[i] == 0) {",
      "                q.push(i);",
      "            }",
      "        }",
      "",
      "        while (!q.empty( )) {",
      "            int u = q.front( );",
      "            q.pop( );",
      "            s_arr.push_back(u);",
      "            for (auto v : adj[u]) {",
      "                indeg[v]--;",
      "                if (indeg[v] == 0) {",
      "                    q.push(v);",
      "                }",
      "            }",
      "        }",
      "",
      "        return s_arr.size( ) == n;",
      "    };",
      ""
    ],
    "description": ""
  }
}
