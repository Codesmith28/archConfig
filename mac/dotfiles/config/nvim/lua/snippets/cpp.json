{
    "Leetcode boilerplate": {
        "prefix": "leet",
        "body": [
            "#ifndef ONLINE_JUDGE",
            "#define _GLIBCXX_DEBUG",
            "#include \"debug.h\"",
            "#else",
            "#define dbg(x...)",
            "#endif",
            "#include<bits/stdc++.h>",
            "",
            "using namespace std;",
            "/* (╯°□°)╯︵ ┻━┻ */",
            "",
            "$1",
            "",
            "/*",
            "",
            "*/",
            "int main() {",
            "    $0",
            "    return 0;",
            "}"
        ],
        "description": "boilerplate code for leetcode problems in C++"
    },
    "Rolling hash simpler": {
        "prefix": "rollsimple",
        "body": [
            "// --- Rolling Hash ---",
            "typedef unsigned long long ull;",
            "const ull base = 911;",
            "const int N = 1e6 + 6;",
            "ull p[N], ha[N];",
            "",
            "void precalc( ) {",
            "    p[0] = 1;",
            "    for (int i = 1; i < N; i++) {",
            "        p[i] = p[i - 1] * base;",
            "    }",
            "}",
            "void build(const string &s) {",
            "    int n = s.size( );",
            "    ha[0] = s[0];",
            "    for (int i = 1; i < n; i++) {",
            "        ha[i] = ha[i - 1] * base + s[i];",
            "    }",
            "}",
            "ull get_hash(int l, int r) {",
            "    if (l == 0) return ha[r];",
            "    return ha[r] - ha[l - 1] * p[r - l + 1];",
            "};",
            "ull pattern_hash(const string &s) {",
            "    ull res = 0;",
            "    for (char c : s) {",
            "        res = res * base + c;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Rolling hash simpler"
    },
    "Boilerplate debugged": {
        "prefix": "dboi",
        "body": [
            "#ifndef ONLINE_JUDGE",
            "#define _GLIBCXX_DEBUG",
            "#include \"library/debug.h\"",
            "#else",
            "#define dbg(x...)",
            "#endif",
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "/* (╯°□°)╯︵ ┻━┻ */",
            "",
            "#define int  long long",
            "#define pii  pair<int, int>",
            "#define endl \"\\n\"",
            "",
            "void solve( ) {",
            "        $0",
            "}",
            "",
            "int32_t main( ) {",
            "        ios_base::sync_with_stdio(false);",
            "        cin.tie(NULL);",
            "        cout.tie(NULL);",
            "",
            "#ifndef ONLINE_JUDGE",
            "        freopen(\"_in.txt\", \"r\", stdin);",
            "        freopen(\"_out.txt\", \"w\", stdout);",
            "#endif",
            "",
            "        int testCases = 1;",
            "        $1cin >> testCases;",
            "",
            "        while (testCases--) {",
            "                solve( );",
            "        }",
            "",
            "        return 0;",
            "}"
        ],
        "description": "debugged boiler plate"
    },
    "Boilerplate with debugging": {
        "prefix": "doi",
        "body": [
            "#ifndef ONLINE_JUDGE",
            "#define _GLIBCXX_DEBUG",
            "#include \"library/debug.h\"",
            "#else",
            "#define dbg(x...)",
            "#endif",
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "/* (╯°□°)╯︵ ┻━┻ */",
            "",
            "#define int  long long",
            "#define pii  pair<int, int>",
            "#define endl \"\\n\"",
            "",
            "void solve( ) {",
            "        $0",
            "}",
            "",
            "int32_t main( ) {",
            "        ios_base::sync_with_stdio(false);",
            "        cin.tie(NULL);",
            "        cout.tie(NULL);",
            "",
            "        int testCases = 1;",
            "        $1cin >> testCases;",
            "",
            "        while (testCases--) {",
            "                solve( );",
            "        }",
            "",
            "        return 0;",
            "}"
        ],
        "description": ""
    },
    "Fenwick Tree 1 based": {
        "prefix": "fenwick",
        "body": [
            "struct BIT {",
            "    int n;",
            "    vector<int> tree;",
            "",
            "    BIT(int size) {",
            "        n = size;",
            "        tree.assign(n + 1, 0); // 1-based indexing",
            "    }",
            "",
            "    /// Add `val` to index `i` (1-based)",
            "    void update(int i, int val) {",
            "        while (i <= n) {",
            "            tree[i] += val;",
            "            i += (i & -i);",
            "        }",
            "    }",
            "",
            "    /// Prefix sum query: sum of elements in [1, i] (1-based)",
            "    int query(int i) {",
            "        int res = 0;",
            "        while (i > 0) {",
            "            res += tree[i];",
            "            i -= (i & -i);",
            "        }",
            "        return res;",
            "    }",
            "",
            "    /// Range sum query: sum of elements in [l, r] (1-based)",
            "    int range_query(int l, int r) {",
            "        return query(r) - query(l - 1);",
            "    }",
            "};",
            ""
        ],
        "description": "Fenwick Tree 1 based"
    },
    "Lazy Segment Tree 1 based": {
        "prefix": "segtree",
        "body": [
            "struct segtree {",
            "    vector<int> tree, lazy;",
            "    int n;",
            "",
            "    segtree(int sz) {",
            "        n = sz;",
            "        tree.assign(4 * n, 0);",
            "        lazy.assign(4 * n, 0);",
            "    }",
            "",
            "    /// Build the segment tree from a 0-based array `arr`",
            "    void build(vector<int> &arr, int node, int st, int en) {",
            "        if (st == en) {",
            "            tree[node] = arr[st];",
            "        } else {",
            "            int mid = st + (en - st) / 2;",
            "            build(arr, 2 * node, st, mid);",
            "            build(arr, 2 * node + 1, mid + 1, en);",
            "            tree[node] = max(tree[2 * node], tree[2 * node + 1]);",
            "        }",
            "    }",
            "",
            "    /// Query max in range [left, right] on 0-based array",
            "    int query(int node, int st, int en, int left, int right) {",
            "        if (lazy[node] != 0) {",
            "            tree[node] += (en - st + 1) * lazy[node];",
            "            if (st != en) {",
            "                lazy[2 * node] += lazy[node];",
            "                lazy[2 * node + 1] += lazy[node];",
            "            }",
            "            lazy[node] = 0;",
            "        }",
            "",
            "        if (right < st || en < left) return 0;",
            "        if (left <= st && en <= right) return tree[node];",
            "",
            "        int mid = st + (en - st) / 2;",
            "        int h1 = query(2 * node, st, mid, left, right);",
            "        int h2 = query(2 * node + 1, mid + 1, en, left, right);",
            "        return max(h1, h2);",
            "    }",
            "",
            "    /// Add `val` to range [left, right] on 0-based array (lazy)",
            "    void range_update(int node, int st, int en, int left, int right, int val) {",
            "        if (lazy[node] != 0) {",
            "            tree[node] += (en - st + 1) * lazy[node];",
            "            if (st != en) {",
            "                lazy[2 * node] += lazy[node];",
            "                lazy[2 * node + 1] += lazy[node];",
            "            }",
            "            lazy[node] = 0;",
            "        }",
            "",
            "        if (right < st || en < left) return;",
            "        if (left <= st && en <= right) {",
            "            tree[node] += (en - st + 1) * val;",
            "            if (st != en) {",
            "                lazy[2 * node] += val;",
            "                lazy[2 * node + 1] += val;",
            "            }",
            "            return;",
            "        }",
            "",
            "        int mid = st + (en - st) / 2;",
            "        range_update(2 * node, st, mid, left, right, val);",
            "        range_update(2 * node + 1, mid + 1, en, left, right, val);",
            "        tree[node] = max(tree[2 * node], tree[2 * node + 1]);",
            "    }",
            "",
            "    /// Point update: set a[idx] = val on 0-based array",
            "    void pt_update(int node, int st, int en, int idx, int val) {",
            "        if (st == en) {",
            "            tree[node] = val;",
            "        } else {",
            "            int mid = st + (en - st) / 2;",
            "            if (idx <= mid)",
            "                pt_update(2 * node, st, mid, idx, val);",
            "            else",
            "                pt_update(2 * node + 1, mid + 1, en, idx, val);",
            "            tree[node] = max(tree[2 * node], tree[2 * node + 1]);",
            "        }",
            "    }",
            "};",
            ""
        ],
        "description": "Lazy Segment Tree 1 based"
    },
    "Sieve of Eratosthenes snippet for prime numbers": {
        "prefix": "sieve",
        "body": [
            "const int N = 2e6;",
            "vector<bool> isPrime(N, true);",
            "vector<int> primes;",
            "",
            "void sieve() {",
            "    isPrime[0] = isPrime[1] = false;",
            "    for (int i = 2; i * i < N; i++) {",
            "        if (isPrime[i]) {",
            "            for (int j = i * i; j < N; j += i) {",
            "                isPrime[j] = false;",
            "            }",
            "        }",
            "    }",
            "    for (int i = 2; i < N; i++) {",
            "        if (isPrime[i])",
            "            primes.push_back(i);",
            "    }",
            "}",
            "$0"
        ],
        "description": "Sieve of Eratosthenes for prime numbers"
    },
    "vectors": {
        "prefix": "vi",
        "body": [
            "vector<int> $1;",
            "$0"
        ],
        "description": "Input vector of integers"
    },
    "vector<vector>": {
        "prefix": "vvi",
        "body": [
            "vector<vector<int>> $1($2, vector<int>($3));",
            "$0"
        ],
        "description": "Input vector of integers"
    },
    "Disjoint Set Union": {
        "prefix": "dsu",
        "body": [
            "class DSU {",
            "  private:",
            "    vector<int> Parent, Rank, Size;",
            "",
            "  public:",
            "    DSU(int n) {",
            "        Parent.assign(n + 1, 1);",
            "        Rank.assign(n + 1, 1);",
            "        Size.assign(n + 1, 1);",
            "        for (int i = 0; i <= n; i++) Parent[i] = i;",
            "    }",
            "",
            "    int Find(int x) {",
            "        if (x != Parent[x]) Parent[x] = Find(Parent[x]);",
            "        return Parent[x];",
            "    }",
            "",
            "    bool Union(int x, int y) {",
            "        int xset = Find(x), yset = Find(y);",
            "        if (xset != yset) {",
            "            if (Rank[xset] < Rank[yset]) {",
            "                Parent[xset] = yset;",
            "                Size[yset] += Size[xset];",
            "            } else {",
            "                Parent[yset] = xset;",
            "                Size[xset] += Size[yset];",
            "                if (Rank[xset] == Rank[yset]) Rank[xset]++;",
            "            }",
            "            return true;",
            "        }",
            "        return false;",
            "    }",
            "",
            "    int getSize(int x) {",
            "        return Size[Find(x)];",
            "    }",
            "};"
        ],
        "description": "Disjoint Set Union"
    },
    "sortSnippet": {
        "prefix": "sa",
        "body": [
            "sort($1.begin(), $1.end() $2);",
            "$0"
        ],
        "description": "Sort a vector"
    },
    "Trie": {
        "prefix": "trie",
        "body": [
            "class Trie {",
            "    struct TrieNode {",
            "        TrieNode* child[26];",
            "        bool is_end;",
            "",
            "        TrieNode() {",
            "            is_end = false;",
            "            for (int i = 0; i < 26; i++) {",
            "                child[i] = nullptr;",
            "            }",
            "        }",
            "    };",
            "",
            "    TrieNode* root;",
            "",
            "public:",
            "    Trie() {",
            "        root = new TrieNode();",
            "    }",
            "",
            "    void insert(const string& key) {",
            "        TrieNode* node = root;",
            "        for (char c : key) {",
            "            int idx = c - 'a';",
            "            if (!node->child[idx]) {",
            "                node->child[idx] = new TrieNode();",
            "            }",
            "            node = node->child[idx];",
            "        }",
            "        node->is_end = true;",
            "    }",
            "",
            "    bool search(const string& key) {",
            "        TrieNode* node = root;",
            "        for (char c : key) {",
            "            int idx = c - 'a';",
            "            if (!node->child[idx]) return false;",
            "            node = node->child[idx];",
            "        }",
            "        return node->is_end;",
            "    }",
            "",
            "    bool starts_with(const string& pref) {",
            "        TrieNode* node = root;",
            "        for (char c : pref) {",
            "            int idx = c - 'a';",
            "            if (!node->child[idx]) return false;",
            "            node = node->child[idx];",
            "        }",
            "        return true;",
            "    }",
            "};",
            ""
        ],
        "description": "Trie"
    },
    "Singly Linked List Node": {
        "prefix": "listnode",
        "body": [
            "struct ListNode {",
            "    int val;",
            "    ListNode *next;",
            "    ListNode(int x) {",
            "        val = x;",
            "        next = NULL;",
            "    }",
            "};"
        ],
        "description": "Snippet for a singly linked list node structure"
    },
    "Binary Tree Node": {
        "prefix": "btnode",
        "body": [
            "struct TreeNode {",
            "    int val;",
            "    TreeNode *left;",
            "    TreeNode *right;",
            "    TreeNode(int x) {",
            "        val = x;",
            "        left = NULL;",
            "        right = NULL;",
            "    }",
            "};"
        ],
        "description": "Snippet for a binary tree node structure"
    },
    "ordered_set": {
        "prefix": "pbds",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp> // Common file",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "template <typename T>",
            "using ordered_set = tree<T,                                  // key type",
            "                         null_type,                          // mapped type; null_type -> like `set`, not `map`",
            "                         std::less<T>,                       // comparator",
            "                         rb_tree_tag,                        // red-black tree (also supports splay trees etc.)",
            "                         tree_order_statistics_node_update>; // adds order-statistics operations"
        ],
        "description": "ordered_set"
    },
    "Custom Hash Struct": {
        "prefix": "custom_hash",
        "body": [
            "struct custom_hash {",
            "    static uint64_t splitmix64(uint64_t x) {",
            "        // http://xorshift.di.unimi.it/splitmix64.c",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "",
            "    size_t operator()(uint64_t x) const {",
            "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
            "};"
        ],
        "description": "Generates a custom hash function using splitmix64"
    },
    "Dijkstra Lambda Alt": {
        "prefix": "dijkstraAlt",
        "body": [
            "auto dj = [&](int src, vector<int> &spath) -> void {",
            "    priority_queue<pii, vector<pii>, greater<pii>> pq;",
            "    pq.push({0, src});",
            "    spath[src] = 0;",
            "",
            "    while (!pq.empty()) {",
            "        auto [curr_dis, curr_node] = pq.top();",
            "        pq.pop();",
            "",
            "        if (spath[curr_node] < curr_dis) continue;",
            "        for (auto [nei, dis] : adj[curr_node]) {",
            "            if (spath[nei] > curr_dis + dis) {",
            "                spath[nei] = curr_dis + dis;",
            "                pq.push({spath[nei], nei});",
            "            }",
            "        }",
            "    }",
            "};"
        ],
        "description": "Dijkstra's algorithm (lambda) using custom spacing."
    },
    "Rabin-Karp Rolling Hash": {
        "prefix": "rabinkarp",
        "body": [
            "class RabinKarp {",
            "private:",
            "    const int BASE = 256;",
            "    const int MOD = 1000000007;",
            "    vector<long long> power;",
            "",
            "public:",
            "    RabinKarp(int maxLength) {",
            "        power.resize(maxLength);",
            "        power[0] = 1;",
            "        for (int i = 1; i < maxLength; i++) {",
            "            power[i] = (power[i-1] * BASE) % MOD;",
            "        }",
            "    }",
            "",
            "    long long computeHash(const string& s) {",
            "        long long hash = 0;",
            "        for (int i = 0; i < s.length(); i++) {",
            "            hash = (hash * BASE + s[i]) % MOD;",
            "        }",
            "        return hash;",
            "    }",
            "",
            "    long long updateHash(long long oldHash, char oldChar, char newChar, int patternLength) {",
            "        oldHash = (oldHash - oldChar * power[patternLength - 1]) % MOD;",
            "        if (oldHash < 0) oldHash += MOD;",
            "        return (oldHash * BASE + newChar) % MOD;",
            "    }",
            "};",
            "",
            "// Usage example:",
            "RabinKarp rk(${1:maxLength});",
            "string text = \"${2:text}\";",
            "string pattern = \"${3:pattern}\";",
            "",
            "long long patternHash = rk.computeHash(pattern);",
            "long long textHash = rk.computeHash(text.substr(0, pattern.length()));",
            "",
            "for (int i = 0; i <= text.length() - pattern.length(); i++) {",
            "    if (patternHash == textHash && text.substr(i, pattern.length()) == pattern) {",
            "        cout << \"Pattern found at index \" << i << endl;",
            "    }",
            "    if (i < text.length() - pattern.length()) {",
            "        textHash = rk.updateHash(textHash, text[i], text[i + pattern.length()], pattern.length());",
            "    }",
            "}",
            "$0"
        ],
        "description": "Rabin-Karp rolling hash algorithm implementation"
    },
    "rolling_hash": {
        "prefix": "rollhash",
        "body": [
            "const int N = 1e6 + 6;",
            "const __int128 base = 33;",
            "const __int128 mod = 1000000000000000003;",
            "__int128 add(__int128 a, __int128 b, __int128 mod) {",
            "    __int128 res = (a + b) % mod;",
            "    if (res < 0) res += mod;",
            "    return res;",
            "}",
            "__int128 mult(__int128 a, __int128 b, __int128 mod) {",
            "    __int128 res = (a * b) % mod;",
            "    if (res < 0) res += mod;",
            "    return res;",
            "}",
            "__int128 power(__int128 a, __int128 b, __int128 mod) {",
            "    __int128 res = 1;",
            "    while (b) {",
            "        if (b % 2 == 1) res = mult(res, a, mod);",
            "        a = mult(a, a, mod);",
            "        b /= 2;",
            "    }",
            "    return res;",
            "}",
            "__int128 pw[N];",
            "__int128 inv[N];",
            "__int128 ha[N];",
            "void precalc( ) {",
            "    pw[0] = 1;",
            "    for (int i = 1; i < N; i++) pw[i] = mult(pw[i - 1], base, mod);",
            "    __int128 pw_inv = power(base, mod - 2, mod);",
            "    inv[0] = 1;",
            "    for (int i = 1; i < N; i++) inv[i] = mult(inv[i - 1], pw_inv, mod);",
            "}",
            "void build(const std::string &s) {",
            "    int n = s.length( );",
            "    for (int i = 0; i < n; i++) {",
            "        ha[i] = add((i == 0) ? 0 : ha[i - 1], mult(pw[i], s[i] - 'a' + 1, mod), mod);",
            "    }",
            "}",
            "__int128 getHash(int x, int y) {",
            "    __int128 res = add(ha[y], (x == 0) ? 0 : -ha[x - 1], mod);",
            "    res = mult(res, inv[x], mod);",
            "    return res;",
            "}"
        ],
        "description": ""
    },
    "power_function": {
        "prefix": "exp",
        "body": [
            "int power(int a, int x) {",
            "    int res = 1;",
            "    whilx) {",
            "        if (x & 1) {",
            "            res = (res * a) % mod;",
            "        }",
            "        a = (a * a) % mod;",
            "        x >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "modular exponentiation"
    },
    "bellman_ford": {
        "prefix": "bellman_ford",
        "body": [
            "    auto bellman_ford = [&]( ) -> void {",
            "        // propogation:",
            "        for (int i = 1; i < n; i++) {",
            "            for (auto e : edges) {",
            "                int a = e.a, b = e.b, x = e.x;",
            "                if (dist[a] != inf) {",
            "                    dist[b] = min(dist[a] + x, dist[b]);",
            "                    dist[b] = max(-inf, dist[b]);",
            "                }",
            "            }",
            "        }",
            " ",
            "        // negative cycle check:",
            "        for (int i = 1; i < n; i++) {",
            "            for (auto e : edges) {",
            "                int a = e.a, b = e.b, x = e.x;",
            "                if (dist[a] != inf) {",
            "                    dist[b] = max(-inf, dist[b]);",
            "                    if (dist[a] + x < dist[b]) {",
            "                        dist[b] = -inf;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "    };",
            " "
        ],
        "description": ""
    },
    "Topological Sort": {
        "prefix": "topo",
        "body": [
            "class Topology {",
            "      private:",
            "        int sz;",
            "        vector<vector<int>> &adj;",
            "        vector<int> indeg;",
            "        vector<int> s_arr;",
            "        bool isDag;",
            "",
            "        bool topoCycle( ) {",
            "                queue<int> q;",
            "                for (int i = 0; i < sz; i++) {",
            "                        if (indeg[i] == 0) {",
            "                                q.push(i);",
            "                        }",
            "                }",
            "                while (!q.empty( )) {",
            "                        int u = q.front( );",
            "                        q.pop( );",
            "                        s_arr.push_back(u);",
            "                        for (int &it : adj[u]) {",
            "                                indeg[it]--;",
            "                                if (indeg[it] == 0) {",
            "                                        q.push(it);",
            "                                }",
            "                        }",
            "                }",
            "                return s_arr.size( ) == sz;",
            "        }",
            "",
            "      public:",
            "        Topology(vector<vector<int>> &adj) : adj(adj) {",
            "                sz = adj.size( );",
            "                indeg.assign(sz, 0);",
            "                for (int u = 0; u < sz; u++) {",
            "                        for (int &it : adj[u]) indeg[it]++;",
            "                }",
            "                isDag = topoCycle( );",
            "        }",
            "",
            "        const vector<int> &getTopo( ) {",
            "                return s_arr;",
            "        }",
            "        bool isDAG( ) {",
            "                return isDag;",
            "        }",
            "};"
        ],
        "description": "Topological Sort"
    },
    "Least Common Ancestor": {
        "prefix": "lca",
        "body": [
            "class LCA {",
            "      private:",
            "        const int LOG = 21;",
            "        int n, root;",
            "        vector<vector<int>> &adj;",
            "        vector<vector<int>> ancs;",
            "        vector<int> depth;",
            "",
            "        void preDfs(int node, int par) {",
            "                ancs[node][0] = par;",
            "                if (par != -1) {",
            "                        depth[node] = depth[par] + 1;",
            "                }",
            "                for (int i = 1; i < LOG; i++) {",
            "                        if (ancs[node][i - 1] != -1) ancs[node][i] = ancs[ancs[node][i - 1]][i - 1];",
            "                }",
            "                for (int it : adj[node]) {",
            "                        if (it != par) preDfs(it, node);",
            "                }",
            "        }",
            "",
            "      public:",
            "        LCA(int n, vector<vector<int>> &adj, int root) : n(n), adj(adj), root(root) {",
            "                ancs.assign(n + 1, vector<int>(LOG, -1));",
            "                depth.assign(n + 1, 0);",
            "                preDfs(root, -1);",
            "        }",
            "",
            "        int getLCA(int a, int b) {",
            "                if (depth[a] > depth[b]) swap(a, b);",
            "",
            "                // bring b to the same depth as a",
            "                int diff = depth[b] - depth[a];",
            "                for (int i = 0; i < LOG; i++) {",
            "                        if (diff & (1 << i)) {",
            "                                b = ancs[b][i];",
            "                        }",
            "                }",
            "                if (a == b) return a;",
            "",
            "                // common lift till same parent",
            "                for (int i = LOG - 1; i >= 0; i--) {",
            "                        if (ancs[a][i] != -1 && ancs[a][i] != ancs[b][i]) {",
            "                                a = ancs[a][i];",
            "                                b = ancs[b][i];",
            "                        }",
            "                }",
            "                return ancs[a][0];",
            "        }",
            "",
            "        int getAncs(int node, int lvl) {",
            "                return ancs[node][lvl];",
            "        }",
            "",
            "        int getDepth(int node) {",
            "                return depth[node];",
            "        }",
            "",
            "        int getDistAncs(int node, int dist) {",
            "                for (int i = 0; i < LOG; i++) {",
            "                        if (dist & (1 << i)) {",
            "                                node = ancs[node][i];",
            "                        }",
            "                }",
            "                return node;",
            "        }",
            "",
            "        int getDist(int a, int b) {",
            "                int lca = getLCA(a, b);",
            "                return (depth[a] - depth[lca]) + (depth[b] - depth[lca]);",
            "        }",
            "};",
            ""
        ],
        "description": "Least Common Ancestor"
    },
    "SegmentTree Snippet v2": {
        "prefix": "segtree2",
        "body": [
            "/// Segment tree snippet",
            "class SegTree {",
            "  private:",
            "    int n;",
            "    vector<int> tree, lazy, &arr;",
            "",
            "    // build the segment tree",
            "    void build(int node, int st, int en) {",
            "        if (st == en) {",
            "            tree[node] = arr[st];",
            "        } else {",
            "            int mid = st + (en - st) / 2;",
            "            build(2 * node, st, mid);",
            "            build(2 * node + 1, mid + 1, en);",
            "            tree[node] = max(tree[2 * node], tree[2 * node + 1]);",
            "        }",
            "    }",
            "",
            "    // apply and propagate lazy value",
            "    void push(int node, int st, int en) {",
            "        if (lazy[node] != 0) {",
            "            tree[node] += lazy[node];",
            "            if (st != en) {",
            "                lazy[2 * node] += lazy[node];",
            "                lazy[2 * node + 1] += lazy[node];",
            "            }",
            "            lazy[node] = 0;",
            "        }",
            "    }",
            "",
            "    // query max in range [left, right]",
            "    int query(int node, int st, int en, int left, int right) {",
            "        push(node, st, en);",
            "",
            "        if (right < st || en < left) return INT_MIN;",
            "        if (left <= st && en <= right) return tree[node];",
            "",
            "        int mid = st + (en - st) / 2;",
            "        int h1 = query(2 * node, st, mid, left, right);",
            "        int h2 = query(2 * node + 1, mid + 1, en, left, right);",
            "        return max(h1, h2);",
            "    }",
            "",
            "    // Add 'val' to elements in range [left, right]",
            "    void rangeUpdate(int node, int st, int en, int left, int right, int val) {",
            "        push(node, st, en);",
            "",
            "        if (right < st || en < left) return;",
            "",
            "        if (left <= st && en <= right) {",
            "            tree[node] += val;",
            "            if (st != en) {",
            "                lazy[2 * node] += val;",
            "                lazy[2 * node + 1] += val;",
            "            }",
            "            return;",
            "        }",
            "",
            "        int mid = st + (en - st) / 2;",
            "        rangeUpdate(2 * node, st, mid, left, right, val);",
            "        rangeUpdate(2 * node + 1, mid + 1, en, left, right, val);",
            "        tree[node] = max(tree[2 * node], tree[2 * node + 1]);",
            "    }",
            "",
            "    // Set arr[idx] = val (0-based)",
            "    void pointUpdate(int node, int st, int en, int idx, int val) {",
            "        push(node, st, en);",
            "",
            "        if (st == en) {",
            "            tree[node] = val;",
            "            return;",
            "        }",
            "",
            "        int mid = st + (en - st) / 2;",
            "        if (idx <= mid)",
            "            pointUpdate(2 * node, st, mid, idx, val);",
            "        else",
            "            pointUpdate(2 * node + 1, mid + 1, en, idx, val);",
            "",
            "        tree[node] = max(tree[2 * node], tree[2 * node + 1]);",
            "    }",
            "",
            "  public:",
            "    SegTree(int sz, vector<int> &arr) : arr(arr) {",
            "        n = sz;",
            "        tree.assign(4 * n, 0);",
            "        lazy.assign(4 * n, 0);",
            "        build(1, 0, n - 1);",
            "    }",
            "",
            "    int query(int left, int right) {",
            "        return query(1, 0, n - 1, left, right);",
            "    }",
            "    void rangeUpdate(int left, int right, int val) {",
            "        rangeUpdate(1, 0, n - 1, left, right, val);",
            "    }",
            "    void pointUpdate(int idx, int val) {",
            "        pointUpdate(1, 0, n - 1, idx, val);",
            "    }",
            "};"
        ],
        "description": "SegmentTree Snippet v2"
    },
    "Knuth-Morris-Pratt Algorithm": {
        "prefix": "kmp",
        "body": [
            "class KMP {",
            "  private:",
            "    vector<int> lps;",
            "    string pattern;",
            "",
            "    void computeLPS( ) {",
            "        int m = pattern.size( );",
            "        int len = 0;",
            "        lps[0] = 0; // lps[0] is always 0",
            "        int i = 1;",
            "",
            "        while (i < m) {",
            "            if (pattern[i] == pattern[len]) {",
            "                len++;",
            "                lps[i] = len;",
            "                i++;",
            "            } else {",
            "                if (len != 0) {",
            "                    len = lps[len - 1];",
            "                } else {",
            "                    lps[i] = 0;",
            "                    i++;",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    set<int> search(const string &text) {",
            "        set<int> occurrences;",
            "        int m = pattern.size( );",
            "        int n = text.size( );",
            "",
            "        int i = 0; // index for text",
            "        int j = 0; // index for pattern",
            "",
            "        while (i < n) {",
            "            if (pattern[j] == text[i]) {",
            "                i++;",
            "                j++;",
            "            }",
            "            if (j == m) {",
            "                occurrences.insert(i - j);",
            "                j = lps[j - 1];",
            "            } else if (i < n && pattern[j] != text[i]) {",
            "                if (j != 0) {",
            "                    j = lps[j - 1];",
            "                } else {",
            "                    i++;",
            "                }",
            "            }",
            "        }",
            "",
            "        return occurrences;",
            "    }",
            "",
            "  public:",
            "    KMP(const string &pat) : pattern(pat) {",
            "        int m = pattern.size( );",
            "        lps.resize(m, 0);",
            "        computeLPS( );",
            "    }",
            "",
            "    vector<int> getLPS( ) const {",
            "        return lps;",
            "    }",
            "",
            "    set<int> getOccurrences(const string &text) {",
            "        return search(text);",
            "    }",
            "};"
        ],
        "description": "Knuth-Morris-Pratt Algorithm"
    },
    "Matrix exponentiation": {
        "prefix": "mexp",
        "body": [
            "template <typename T> class Matrix {",
            "  public:",
            "    vector<vector<T>> mat;",
            "    int rows, cols;",
            "",
            "    // Constructor: rows x cols, optionally identity (only for square matrices)",
            "    Matrix(int r, int c, bool identity = false) : rows(r), cols(c) {",
            "        mat.assign(r, vector<T>(c, 0));",
            "        if (identity) {",
            "            assert(r == c); // identity only for square",
            "            for (int i = 0; i < r; i++) mat[i][i] = 1;",
            "        }",
            "    }",
            "",
            "    // Multiply this matrix with another",
            "    Matrix<T> mult(const Matrix<T> &postMult) const {",
            "        assert(cols == postMult.rows);",
            "        Matrix<T> res(rows, postMult.cols);",
            "        for (int i = 0; i < rows; i++) {",
            "            for (int k = 0; k < cols; k++) {",
            "                if (!mat[i][k]) continue;",
            "                for (int j = 0; j < postMult.cols; j++) {",
            "                    res.mat[i][j] = (res.mat[i][j] + mat[i][k] * postMult.mat[k][j]);",
            "                }",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "",
            "    // Raise square matrix to power",
            "    Matrix<T> power(int exp) const {",
            "        assert(rows == cols);",
            "        Matrix<T> res(rows, cols, true); // identity",
            "        Matrix<T> base = *this;",
            "        while (exp > 0) {",
            "            if (exp & 1) res = res.mult(base);",
            "            base = base.mult(base);",
            "            exp >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "Matrix exponentiation"
    },
    "check if a large number is prime or not": {
        "prefix": "isprime",
        "body": [
            "/**",
            " * Miller-Rabin Primality Test",
            " * Deterministic for n < 3 * 10^18 using the specified witnesses.",
            " * Time Complexity: O(k * log^3 n) where k is the number of witnesses.",
            " */",
            "bool isPrimeMillerRabin(long long n) {",
            "    if (n < 2) return false;",
            "    if (n == 2 || n == 3) return true;",
            "    if (n % 2 == 0) return false;",
            "",
            "    // 1. Factor n-1 into d * 2^r",
            "    long long d = n - 1;",
            "    int r = 0;",
            "    while (d % 2 == 0) {",
            "        d /= 2;",
            "        r++;",
            "    }",
            "",
            "    // 2. Deterministic witnesses for 64-bit integers",
            "    static const std::vector<long long> witnesses = {",
            "        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37",
            "    };",
            "",
            "    for (long long a : witnesses) {",
            "        if (n <= a) break;",
            "",
            "        // 3. Compute a^d % n using Binary Exponentiation",
            "        long long x = 1;",
            "        long long base = a % n;",
            "        long long temp_d = d;",
            "        while (temp_d > 0) {",
            "            if (temp_d & 1) x = (__int128)x * base % n;",
            "            base = (__int128)base * base % n;",
            "            temp_d >>= 1;",
            "        }",
            "",
            "        // 4. If x is 1 or n-1, this base doesn't prove it's composite",
            "        if (x == 1 || x == n - 1) continue;",
            "",
            "        // 5. Square x, r-1 times",
            "        bool composite = true;",
            "        for (int i = 0; i < r - 1; i++) {",
            "            x = (__int128)x * x % n;",
            "            if (x == n - 1) {",
            "                composite = false;",
            "                break;",
            "            }",
            "        }",
            "",
            "        // If we never hit n-1, it is definitely composite",
            "        if (composite) return false;",
            "    }",
            "",
            "    return true;",
            "}"
        ],
        "description": "check if a large number is prime or not"
    },
    "modular arithmatic package": {
        "prefix": "mint",
        "body": [
            "// clang-format off",
            "template <int MOD>",
            "struct ModInt {",
            "    int val;",
            "    ",
            "    // Constructors",
            "    ModInt(long long v = 0) { if (v < 0) v = v % MOD + MOD; val = v % MOD; }",
            "    ",
            "    // Basic Arithmetic",
            "    ModInt& operator+=(const ModInt& other) { val += other.val; if (val >= MOD) val -= MOD; return *this; }",
            "    ModInt& operator-=(const ModInt& other) { val -= other.val; if (val < 0) val += MOD; return *this; }",
            "    ModInt& operator*=(const ModInt& other) { val = (int)(1LL * val * other.val % MOD); return *this; }",
            "    ModInt& operator/=(const ModInt& other) { return *this *= other.inv(); }",
            "    ModInt operator-() const { return ModInt(0) - *this; }",
            "    ",
            "    friend ModInt operator+(ModInt a, const ModInt& b) { return a += b; }",
            "    friend ModInt operator-(ModInt a, const ModInt& b) { return a -= b; }",
            "    friend ModInt operator*(ModInt a, const ModInt& b) { return a *= b; }",
            "    friend ModInt operator/(ModInt a, const ModInt& b) { return a /= b; }",
            "",
            "    // Power and Inverse",
            "    ModInt pow(long long n) const {",
            "        ModInt res = 1, a = *this;",
            "        while (n > 0) {",
            "            if (n & 1) res *= a;",
            "            a *= a;",
            "            n >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "    ModInt inv() const {",
            "        return pow(MOD - 2);",
            "    }",
            "",
            "    // I/O Overloading",
            "    friend ostream& operator<<(ostream& os, const ModInt& m) { return os << m.val; }",
            "    friend istream& operator>>(istream& is, ModInt& m) { long long v; is >> v; m = ModInt(v); return is; }",
            "};",
            "",
            "const int MOD = 998244353;",
            "using mint = ModInt<MOD>;",
            "// clang-format on"
        ],
        "description": "modular arithmatic package"
    },
    "mod arithmatic": {
        "prefix": "minty",
        "body": [
            "",
            "using ll = long long;",
            "ll pow_mod(ll a, ll n, ll mod) {",
            "        a %= mod;",
            "        ll res = 1;",
            "        while (n) {",
            "                if (n % 2) res = res * a % mod;",
            "                a = a * a % mod;",
            "                n /= 2;",
            "        }",
            "        return res;",
            "}",
            "ll inv_mod(ll a, ll mod) {",
            "        return pow_mod(a, mod - 2, mod);",
            "}",
            "template <const long long int mod> struct modint {",
            "        using mint = modint<mod>;",
            "        long long int x;",
            "        modint(long long int _x = 0) : x(_x % mod) {",
            "                if (x < 0) x += mod;",
            "        }",
            "        long long int val( ) {",
            "                return x;",
            "        }",
            "        mint &operator=(const mint &a) {",
            "                x = a.x;",
            "                return *this;",
            "        }",
            "        mint &operator+=(const mint &a) {",
            "                x += a.x;",
            "                if (x >= mod) x -= mod;",
            "                return *this;",
            "        }",
            "        mint &operator-=(const mint &a) {",
            "                x -= a.x;",
            "                if (x < 0) x += mod;",
            "                return *this;",
            "        }",
            "        mint &operator*=(const mint &a) {",
            "                x *= a.x;",
            "                x %= mod;",
            "                return *this;",
            "        }",
            "        mint operator-( ) const {",
            "                return mint(0) - *this;",
            "        }",
            "        mint pow(long long int n) {",
            "                if (!n) return 1;",
            "                mint a = 1;",
            "                mint _x = x;",
            "                while (n) {",
            "                        if (n & 1) a *= _x;",
            "                        _x = _x * _x;",
            "                        n >>= 1;",
            "                }",
            "                return a;",
            "        }",
            "        mint inv( ) {",
            "                return pow(mod - 2);",
            "        }",
            "        mint &operator/=(mint &a) {",
            "                return *this *= a.inv( );",
            "        }",
            "        friend mint operator+(const mint &a, const mint &b) {",
            "                return mint(a) += b;",
            "        }",
            "        friend mint operator-(const mint &a, const mint &b) {",
            "                return mint(a) -= b;",
            "        }",
            "        friend mint operator*(const mint &a, const mint &b) {",
            "                return mint(a) *= b;",
            "        }",
            "        friend mint operator/(const mint &a, mint b) {",
            "                return mint(a) /= b;",
            "        }",
            "};",
            "const int mod = 100000007;",
            "using mint = modint<mod>;"
        ],
        "description": "mod arithmatic"
    },
    "generate submasks": {
        "prefix": "gensubmasks",
        "body": [
            "void genSubmasks(int mask) {",
            "        for (int sub = mask;; sub = (sub - 1) & mask) {",
            "                cout << bitset<4>(sub) << \"\\n\"; // adjust size if needed",
            "                if (sub == 0) break;",
            "        }",
            "}"
        ],
        "description": "generate submasks"
    },
    "Sum over Subset": {
        "prefix": "sos",
        "body": [
            "// SOS: Sum Over Subsets",
            "vector<int> SOS(int n, vector<int> &arr) { ",
            "        vector<int> dp(1 << n, 0);",
            "        for (int mask = 0; mask < (1 << n); mask++) {",
            "                dp[mask] = arr[mask];",
            "        }",
            "        for (int i = 0; i < n; i++) {",
            "                for (int mask = 0; mask < (1 << n); mask++) {",
            "                        if ((mask & (1 << i))) {                 // subset condition",
            "                                dp[mask] += dp[mask ^ (1 << i)]; // operation",
            "                        }",
            "                }",
            "        }",
            "        return dp;",
            "}"
        ],
        "description": "Sum over Subset"
    }
}
